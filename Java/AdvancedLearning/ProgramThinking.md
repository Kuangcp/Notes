`目录 start`
 
- [开发思想](#开发思想)
    - [抽象](#抽象)
    - [代码质量分析](#代码质量分析)
        - [Checkstyle](#checkstyle)
        - [FindBugs](#findbugs)
    - [DDD 领域驱动设计](#ddd-领域驱动设计)
    - [TDD 测试驱动开发](#tdd-测试驱动开发)
        - [测试技术](#测试技术)
            - [测试替身](#测试替身)
                - [虚设对象](#虚设对象)
                - [存根对象](#存根对象)
                - [伪装替身](#伪装替身)
                - [模拟对象](#模拟对象)
        - [Mockito学习](#mockito学习)
    - [组件模型](#组件模型)
        - [SOA](#soa)
        - [微服务](#微服务)
- [编程习惯](#编程习惯)
    - [接口定义](#接口定义)
    - [日志规范](#日志规范)
    - [异常处理](#异常处理)
    - [配置文件](#配置文件)

`目录 end` *目录创建于2018-01-22* | 更多: [CSDN](http://blog.csdn.net/kcp606) | [oschina](https://my.oschina.net/kcp1104) | [码云](https://gitee.com/kcp1104) 
****************************************
# 开发思想
> 有关开发的理论性思想,编写,测试,部署等

## 抽象
- [码农翻身:抽象：程序员必备的能力 ](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513062&idx=1&sn=a3b4a2962d8e82471192d9606b0a2722&scene=21#wechat_redirect)

> 稍微注意一下就会发现: 抽象层次越高，接口的语意就越模糊，适用的范围就越广，到最后就会变成数学模型或者概念。  
但是抽象成数学模型和算法通常是可遇而不可求的， 这种情况下，我们需要退而求其次，试图抽象成若干个正交的概念，来降低复杂度。  
你在处理x轴相关的事情时，不用考虑其他的y和z 相关的东西，因为你知道他们不会受到影响， 这样问题的复杂度就从3维一下子下降到1维！更容易把握了。  
如果你说了，我的整个系统还没法抽象成正交的概念， 那只好再退一步，在局部使用接口。  
其实 一组定义良好的接口一定是正交的，不然的话接口之间的依赖就会让实现非常麻烦。 
>> 在著名的《设计模式》一书中，其实在反复强调一点: 发现变化并且封装变化，针对接口编程而不是实现编程。 很多人看书是只关注具体的模式，而忽略了模式的本质目的。  

抽象能力的高低，很大程度上反映了一个程序员的能力的高低

*********************************
## 代码质量分析
- 测试对代码的覆盖率
- 代码的格式是否清晰，有助于差异比较和可读性
- 是否很可能会出现NPE
- 是否忘记了域对象中的equals和hashCode方法

### Checkstyle
### FindBugs


*************************************************
## DDD 领域驱动设计

> [参考博客](http://kb.cnblogs.com/page/117717/) | [讨论](http://www.cnblogs.com/netfocus/p/3307971.html) | [基础](http://www.cnblogs.com/netfocus/archive/2011/10/10/2204949.html)

********************
## TDD 测试驱动开发
> Java程序员修炼之道 测试驱动开发章节

![p276.jpg](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p276.jpg)

`TDD带来的好处`
- 更清晰的代码 只写需要的代码
- 更好的设计  有些开发人员管TDD叫测试驱动的设计
- 更出色的灵活性 TDD会鼓励按接口编码
- 更快速的反馈  不会直到系统上线才知道bug的存在

`红 - 绿 - 重构循环`
- 先编写不能通过测试的红色代码，就是一个简单的思路编写
- 然后修改，让测试通过，然后完善设计，进行重构编写，又进入红绿阶段，然后再重构

- 重构是为了通过测试你写的快速实现，重构减轻自己和别人的技术债务(临时凑合出来的设计或代码将来会付出更多的工作)
    - 有了通过测试， 就可以放心的重构，应该实现的业务逻辑就不可能会被忽视
- `多个测试用例 为了覆盖更多情况`
    - 按照TDD风格，就应该为之前编写的测试用例，进行多路径全覆盖，这个测试依然是红绿重构循环。

`深入思考 红 绿 重构循环`
- 失败测试（红）
    - 一些开发人员喜欢编写编译失败的测试，喜欢等到绿色步骤才提供实现代码
    - 也有一些开发人员喜欢先把测试调用的方法签名写出来，这样虽然编译能通过，但还是失败
- 通过测试
    - 这一步应该尽量少写代码，只要能测试通过即可。
- 重构
    - 许多地方需要重构，一般是： 去掉硬编码的变量，
    - 或把大方法拆分，对于面向对象来说应该遵循 SOLID 原则 [解释SOLID原则](/Java/模式之禅.md)
    - 可以把通用的设置和拆卸代码提取出来。可以重命名测试，以便于更准确地反应他的意图，根据静态分析工具例如`CheckStyle` `FindBugs`
![p283.jpg](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p283.jpg)
- 应该尽可能的遵守单个测试循环的开发模型，不要同时开多个测试循环，一堆红色

_JUnit_
- 主要的三个特性： 
    - 用于测试预期结果和异常的断言， assertEquals()
    - 设置和拆卸通用测试数据的能力， @Before @After
    - 运行测试套件的测试运行器

_一个基本的JUnit测试_
- @Before 标记方法， 测试运行前准备测试数据
- @After 标记方法， 测试运行完成后拆卸测试数据
- @Test 测试方法 例如：预期的异常`@Test(expected=NullPointException.class)`

### 测试技术
#### 测试替身
> 泛指任何出于测试目的的替换真实对象的假冒对象，为了解决测试代码的依赖项问题。  
四种方式： 虚设，伪装，存根，模拟

![p286](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Book/Java7Developer/p286.jpg)

##### 虚设对象
- 他是用来填充参数列表，填补那些总也不会用的必填域。大多数情况下，甚至可以传入null，就是把需要的参数虚拟出来
    - 只是为了避免NPE，让代码能跑起来

##### 存根对象
- 用来代替真实环境对象，需要有做出相同响应的对象，就是存根对象
    - 将一些外部类或三方资源，写一个类，以及对应的方法，来提供测试运行

##### 伪装替身
- 伪装替身，可以看作是存根的升级。他做的工作几乎是和生产代码是一样的，单位了满足测试需求也会使用便捷的方式
    - 例如 内存数据库HSQLDB 的使用，

##### 模拟对象
- 存根对象的调用通常会返回形同的结果。所以不能模拟任何与状态有关的行为，模拟对象就能够更好的胜任
    - 在准备要用的模拟对象时，告诉他会有哪些调用，以及对应的相应，模拟会和DI结合更好。可以用一个虚拟的对象，这个对象完全按照已知方式行动
- 模拟类库：[Mockito官网](http://mockito.org)
    - 调用mock()方法创建模拟对象，并将模拟目标类型的class对象作为参数传进去。
    - 然后要把模拟对象需要的行为记录下来，通过 when方法表明要记录哪些方法的行为，然后用thenReturn方法指定期望结果。


*******************
### Mockito学习

*************************
## 组件模型
### SOA
> [百度百科定义](https://baike.baidu.com/item/SOA/2140650)

### 微服务
> [码农翻身:从SOA到微服务](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513674&idx=1&sn=fbc727b7c8ff6d03f5d53478b6d4e585&chksm=80d67a89b7a1f39ff0c3589a4a4076e323fab18379fc8d085c133b88e4db104f87988b29d246&scene=21#wechat_redirect)

- [码农翻身:我是一个函数](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513873&idx=1&sn=2383f099fb353e59649167e723575158&chksm=80d67bd2b7a1f2c4ae61704b8a2bd330764d20f0e2fafa6fdff55c99ea68272b3cff851684cc&scene=21#wechat_redirect) `详解了RPC, 也就是RMI(远程过程调用)规范的实现`


********************************
# 编程习惯
-  [知乎专栏-程序员你为什么这么累？](https://zhuanlan.zhihu.com/p/28705206) | [专栏的源码](https://github.com/xwjie/PLMCodeTemplate)
    - [接口定义](https://zhuanlan.zhihu.com/p/28708259)
    - [Controller规范](https://zhuanlan.zhihu.com/p/28717374)
    - [日志建议](https://zhuanlan.zhihu.com/p/28629319)
    - [异常处理规范](https://zhuanlan.zhihu.com/p/29005176)
    - [参数校验和国际化规范](https://zhuanlan.zhihu.com/p/29129469)
    - [配置文件的定义](https://zhuanlan.zhihu.com/p/29191233)

> 优先使用组合而不是继承, 继承破坏了封装性, 因为父类的很多细节对子类是可见的, 父类的变化可能极大的影响子类  
> 面向接口编程, 而不是实现编程 
## 接口定义
- 先有统一的接口定义规范，然后有AOP实现。先有思想再有技术。
- 现在知道为什么要返回统一的一个ResultBean了：
    - 为了统一格式
    - 为了应用AOP
    - 为了包装异常信息

## 日志规范

## 异常处理
- 所以，我对开发人员的要求就是，绝大部分场景，不允许捕获异常，不要乱加空判断。只有明显不需要关心的异常，如关闭资源的时候的io异常，可以捕获然后什么都不干，其他时候，不允许捕获异常，都抛出去，到controller处理。空判断大部分时候不需要，你如果写了空判断，你就必须测试为空和不为空二种场景，要么就不要写空判断。
- 强调，有些空判断是要的，如：参数是用户输入的情况下。但是，大部分场景是不需要的（我们的IT系统里面，一半以上不需要），如参数是其它系统传过来，或者其他地方获取的传过来的，99.99%都不会为空，你判断来干嘛？就抛一个空指针到前台怎么啦？何况基本上不会出现。
- 总结：
    - 开发组长定义好异常，异常继承RuntimeException。
    - 不允许开发人员捕获异常。（异常上对开发人员就这点要求！异常都抛出到controller上用AOP处理）
    - 后台（如队列等）异常一定要有通知机制，要第一时间知道异常。
    - 少加空判断，加了空判断就要测试为空的场景！


## 配置文件
千万业务代码里面不要和读取配置的代码耦合在一起。切记！
